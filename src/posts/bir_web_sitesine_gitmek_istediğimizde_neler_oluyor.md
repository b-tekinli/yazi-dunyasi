Bir web sitesine gitmek istediğimizde neler oluyor?
===================================================

### Modern web nasıl çalışır?

![](https://cdn-images-1.medium.com/max/800/0*o1e_2SYlsTvRzYpO.png)

Herkese merhaba, browser’a girdim ve URL’e `beyza.com` yazdım. Fakat başına da `http` ya da `https` eklemeden enter’a bastım. Bu durumda arka planda neler oluyor adım adım en ince detaylara kadar size aktarmaya çalışacağım.

Öncelikle bilgisayarı ilk açtığımızda internete ihtiyacımız var ve işletim sistemimizin ağ bağdaştırıcısı (bu ethernet ya da wifi olabilir) local ağımızda 1 adet duyuru mesajı çıkıyor **_“IP adresi istiyorum”_** şeklinde. Bu mesaja da DHCP Discover mesajı diyoruz. Tabii bu mesajı gönderebilmek için bir IP adresine ihtiyacımız var çünkü internet alt yapısı IP adresleriyle çalışır. Fakat zaten amacımız bir IP adresi istemekti. O zaman nasıl mesajı atıyor? İşte bu yüzden en başta IP adresimiz `0.0.0.0` olarak belirleniyor. Bunun dışında bir de iletişim protokolü kullanarak mesajı atması gerektiği için UDP üzerinden broadcast olarak yani local ağdaki tüm cihazlara iletilecek şekilde gönderiyor. Buradan da hedef IP adresinin `255.255.255.255` olarak belirlendiğini anlıyoruz tüm cihazlara iletileceği için. Fakat bu mesaj DHCP’ye özel bir formatta oluşturulup atıldığı için sadece DHCP cevap veriyor. Mesajın içerisindeki veri bilgisayarımızın MAC adresi. Zaten ARP tablosunda tutup bilgisayarımızı tanımak için MAC adresine ihtiyacı var. Kısaca mesajı özetleyecek olursak şöyle göründüğünü söyleyebiliriz:  
\- **Kaynak IP adresi:** `0.0.0.0` _(Benim IP adresim yok)_  
\- **Hedef IP adresi:** `255.255.255.255` _(Local ağdaki tüm cihazlara gönderiyorum)_  
\- **MAC adresi:** Bilgisayarın kimliği _(mesela 00:1A:2B:3C:4D:5E olabilir)_

Peki bu mesajı alan DHCP sunucusu nasıl yanıt verecek? Bilmemiz gereken şey bu DHCP sunucusunun modemimizin içinde olması ve **_“Bu bilgisayara bir IP adresi sağlayabilirim”_** şeklinde yanıt vermesi. Bu yanıta da DHCP Offer diyoruz. Şimdi biraz da bu mesajın ne olduğuna ve ne içerdiğine bakalım. Yanıt olarak verilen bu mesaj bilgisayarımıza geçici olarak bir IP adresi verir. Fakat sadece IP vermekle kalmayıp bilgisayarımızın internete çıkabilmesi için gerekli olan tüm ayarları sağlayacaktır. Mesela hangi DNS ile iletişimde olacağı, subnet mask, gateway gibi. Örneklendirirsek daha iyi olacaktır. Diyelim ki DHCP Offer yanıtı geldi ve bize önerdiği IP adresi `192.168.1.12` bunun üzerinden devam edelim.  
\- **Önerilen IP adresi:** `192.168.1.12`  
\- **Gateway:** `192.168.1.1` _(yani modemin IP adresi)_  
\- **DNS sunucusu:** `192.168.1.1` _(ya da kullandığımız ISP’nin DNS sunucusu)  
_\- **Subnet Mask:** `255.255.255.0` _(bu arada bu C sınıfı bir IP adresi olduğunu belirtiyor yani ağın yapısını belirtiyor eğer çok daha detaylı bilgi almak isterseniz buradaki_ [**_Network_**](/post/1) _adlı yazımı da okuyabilirsiniz)_

Bu mesaj bilgisayarımıza yanıt olarak geldi IP adresinin geçici olarak bilgisayara atanabileceğini belirtti tamam ama bilgisayarımız daha bu adresi kabul etmedi. Bilgisayarımız bu mesaja DHCP Request adı verilen mesajla **_”Bu IP adresini kullanmayı kabul ediyorum”_** şeklinde karşılık vererek onay vermiş oluyor. Hatta bu mesaj da broadcast olarak gönderiliyor ama yine sadece DHCP sunucusu işleyebiliyor ona özel formatta olduğundan. Peki şimdi artık bilgisayarımız bu IP adresini aldı mı? Hayır.. DHCP sunucusu da DHCP Request mesajını aldıktan sonra **_“Tamam bu IP adresini senin için ayırıyorum”_** diyerek son kez DHCP Acknowledgement (ACK) adı verilen bir mesaj daha gönderiyor. Bu mesajla artık geçici IP adresinin verilme işleminin tamamlandığını bildirmiş olur ve adı üstünde geçici olduğu için ne kadar süreyle verileceğini de söyler. Bu süre lease time yani kira süresi olarak adlandırılır. Artık bilgisayarımız internete çıkabilmek için gerekli tüm ağ bilgilerine sahip diyebiliriz.

![](https://cdn-images-1.medium.com/max/800/1*RmydOcmN5QTvaq2F9NmWmQ.png)

Bundan sonraki kısımda tarayıcımızı açıp URL kısmına `beyza.com` yazdığımızı düşünelim. Browser, yazdığım bu ifadeyi analiz edip URL olarak algılayacaktır. Fakat doğru bir şekilde anlaşılması için http ya da https gibi protokollere ihtiyacı var. Protokol belirtmediğimiz için otomatik olarak http ya da https eklemeye karar verecek ve en güvenli olan protokolü seçmek isteyecektir. Peki bu süreç nasıl işliyor yani tarayıcı nasıl karar veriyor? Bazı siteler, Chrome gibi tarayıcılara **_“HSTS (HTTP Strict Transport Security)”_** adında güvenlik politikası uyguluyor. Bunu Türkçe’ye HTTP Sıkı Aktarım Güvenliği olarak çevirebiliriz. Bu politika da tarayıcıya kullanıcıların mutlaka https kullanarak bağlanmasını söyler. Chrome da kendi içindeki HSTS listesine önceden yüklenmiş popüler siteler için bu politikayı zorlar. Eğer `beyza.com` sitesi bu HSTS listesinde bulunuyorsa, tarayıcı http üzerinden bağlantıyı kabul etmez ve sadece https üzerinden bağlanmaya zorlanır. Mesela google ya da banka web siteleri gibi HSTS listesinde olan bir siteye http üzerinden bağlanmaya çalışırsak chrome bunu otomatik olarak değiştirip https üzerinden bağlanır. Şimdi de browser, HSTS listesini nasıl sorguluyor diye bir soru çıkageldi değil mi? Şöyle ki, bu liste tarayıcının hafızasında ya da veri dosyalarında saklanıyor diyebiliriz. Tabii bu liste özel bir veri yapısıyla saklanıyor ve hızlı bir şekilde sonuç almak için de hash tablosu ya da search tree gibi verimli bir algoritmayla sorgulanıyor. Dolayısıyla tüm listeyi kontrol etmiyor. Chrome geliştiricileri ve güvenlik ekipleri tarafından bu liste düzenli olarak güncelleniyor. Bunlar dışında eğer sadece `beyza` yazsaydık önce DNS çözümleme yaparak bunun gerçek bir web adresi olup olmadığını kontrol edecekti. Fakat biz tam bir domain adı yazdığımız için bunu URL olarak işledi o yüzden DNS üzerinden siteye direkt olarak bağlanmaya çalışacak.

![](https://cdn-images-1.medium.com/max/800/1*9SEmqE6sCwIB1QLbX6Mw8g.png)

Şimdi gelelim DNS kısmına. Tarayıcı, ilk olarak bağlantı kurmak için `https://beyza.com` haline getirmiş olduğu URL’i kullanmayı dener. Tam bu noktada belirttiğimiz siteye gitmek için bir IP adresine ihtiyaç duyar. Fakat domain olarak belirttiğimiz adresler insan tarafından daha anlaşılır olduğu için bunu IP adresine çevirmek zorunda. Zaten yazının en başında da belirtmiştik internet alt yapısının IP adresleriyle çalıştığını. İşte burada da DNS kavramının kilidi açılıyor bizim için. DNS sorgu yaparak bu sitenin IP adresini isteyecek ama bir sürü evreden geçiyor. Tarayıcı önce bilgisayarımızın önbelliğini kontrol eder. Mesela ben Ubuntu kullandığım için `/etc/hosts` dosyasına bakar. Eğer burada `beyza.com` adresine ulaşmak için yapılan bir DNS sorgusunun sonucu varsa onu kullanacak ama ilk defa bu adrese gideceğimiz için orada bulamayacak. Peki bulamadığında ne oluyor? Bilgisayarımız sorguyu modemimize iletiyor. Bu iletim, eğer ethernet kablosuyla bağlıysanız onunla değilseniz kablosuz bağlantı üzerinden iletiliyor. Modem de kendi DNS önbelleğinde domain adresini arıyor. Daha önce sorgulamadığımız için orada da bulamıyor ve ISP’mizin yani kullandığımız internet servis sağlayıcımızın (Türknet, Türk Telekom vs.) DNS sorgularına yönlendirecek. Sorgu, modemi terkedip ağdan çıkıyor ve tam bu noktada sokağa adım atmış oluyor.

![](https://cdn-images-1.medium.com/max/800/1*lVNj3ngpourw9AlH1FOe5A.png)

İsteğimiz modemdeki kablo üzerinden dışarı çıkıp sokaktaki dağıtıcı kutuya gidiyor. Sokağımızdaki tüm ISP’lerden gelen sorgular oradan dağıtılıyor yani diğer kullanıcıların da bağlı olduğu bir bağlantı noktası diyebiliriz. Bu kutudan çıkan hatlar ISP’mizin bölgesel santraline yönlendiriliyor. Bu santral de ISP’mizin ana bağlantı merkezi (backbone ağı) fakat buraya gelene kadar sokaktan çıkıp cadde oradan çıkıp semt oradan da ilçe gibi daha birçok yerden geçiyor. En son ana merkeze geldiğinde burada sinyal fiber optik kablolar üzerinden gittiği için ışık hızında uzak mesafelere hızlıca erişim sağlayabiliyor. Artık sinyal ISP’mizin kendi DNS sunucusuna (Recursive DNS) geldiğinde burada da yine ISP DNS‘inin önbelleğinde domain sorgulanıyor. Eğer bulamazsa bir üst düzey DNS sunucularına yönlendirilmek üzere recursive DNS sorgulama süreci başlıyor. Recursive DNS, adı üstünde tekrarlayıcı ve bizim yerimize sorgulanması gereken tüm DNS’lerle muhatap olarak tüm işi kendisi yapıyor. Bu noktada DNS zincirleme sorgu tamlaması başlıyor diyebiliriz 😅 Bu süreç başlamadan önce BGP (Border Gateway Protocol) protokolünden de bahsetmemiz gerekiyor.

![](https://cdn-images-1.medium.com/max/800/0*PtnIEq-vaMpvkBKG.png)

Recursive DNS, Authoritative DNS’e ulaşana kadar birçok farklı ağ üzerinden geçmesi gerekiyor ve buradaki yönlendirme haritası BGP’dir diyebiliriz. İnternette, dünya çapındaki ağlar AS (Autonomous System) adı verilen ISP’ler, şirket ya da üniversiteler gibi kurumların sahip olduğu farklı farklı ağlardan oluşuyor. Her AS kendi IP bloklarına sahip ve o bloklar aracılığıyla AS’lerle bağlantı kuruyor. BGP de bu noktada AS’lerin birbiriyle nasıl bağlantı kuracağını ve hangi yollar üzerinden gideceğini belirleyen protokol oluyor. Kısaca harita görevi görüyor ve paketlerin hangi AS’lerden geçeceğini belirliyor. Aynı, arabayla giderken yolumuzu kaybettiğimizde navigasyona sarılarak bize en verimli güzergahı bulmasını istediğimizdeki gibi en verimli ve hızlı yolu belirliyor. Birazdan anlatacağım tüm süreçte yolu BGP’nin belirlediğini bilelim.

DNS kısmına geri dönelim. Öncelikle Recursive DNS aradığı IP adresinin nerde olduğunu bilemeyebilir. Bu yüzden önce Root DNS adı verilen en üst düzey DNS sunucusuna sorgu gönderir. Bu arada dünyada yaklaşık 13 tane root sunucu var bonus bilgi olsun çok daha detaylı bilgi edinmek isterseniz [burayı](https://www-recordedfuture-com.translate.goog/threat-intelligence-101/cyber-threat-landscape/dns-root-servers?_x_tr_sl=en&_x_tr_tl=tr&_x_tr_hl=tr&_x_tr_pto=tc&_x_tr_hist=true) okuyabilirsiniz.

![](https://cdn-images-1.medium.com/max/800/0*dXNxedVK2l2mJLYy)

Yukarıdaki resimde de gördüğünüz gibi Root DNS en üstte bulunur. Root DNS, tüm domainlerin üst düzey bilgi dağıtımını yapar. Recursive DNS, Root DNS’e gidip **_“beyza.com’un IP adresini nerede bulabilirim?”_** diye sorar. Root DNS ise **_“Ben com uzantılı domainlerin ayrıntılarını falan bilmem ama .com alan adları için bilgileri tutan TLD (Top Level Domain) DNS’e yönlendirebilirim”_** diyerek TLD DNS’in IP adresini Recursive DNS’e verir. Ardından Recursive DNS gidip TLD DNS’in `.com` için özel sunucusuna sorgu gönderir. TLD DNS’e şöyle bir göz atalım önce.

![](https://cdn-images-1.medium.com/max/800/1*H8XxIw4AfI4dRU6sup2orQ.png)

Buraya bakarak sadece `.com` için özel olarak attığımızı daha net anlayabiliriz. Recursive DNS, TLD DNS’e **_“beyza.com’un IP adresi nerede bulunabilir?”_** diye sorar. TLD DNS de **_“beyza.com domaininin authoritative DNS’ine gitmelisin”_** diyerek Recursive DNS’imize onun IP adresini vererek yönlendirir. Authoritative (yetkili) DNS, domain hakkında en doğru bilgiyi sağlayan sunucudur diyebiliriz çünkü direkt olarak domain sahibinin kontrolünde olan sunucu burasıdır. Kısaca sorgu yaptığımız son kale diyebiliriz. Kafanız karıştıysa bile merak etmeyin çizdiğim yolu vericem o zaman çok daha iyi oturacak her şey. Recursive DNS, Auth DNS’e gidip **_“beyza.com’un IP adresi nedir?”_** diye sorar. Önceden domain yöneticileri gerekli bilgileri Auth DNS’e sağlamıştır. Mesela IP adresi ya da diğer DNS kayıtlarını auth dns zaten kendinde tutar. Bu yüzden auth dns, ilgili domain hakkında kesin bilgilere sahip olduğundan Recursive DNS’e **_“beyza.com’un IP adresi_** `12.1.1.12` diyerek direkt olarak cevabı verir.

> Unutmayalım ki Recursive DNS aslında bizim ISP’mizin DNS’i olduğu için bizle aynı ISP’yi kullanarak önceden `"beyza.com”` sorgusu yapmış olan kullanıcılar varsa direkt olarak kendi önbelleğinde bulup bize verebilirdi yani çok daha hızlı cevap alabilirdik. Farklı bakış açıları kazandırmak için bunu da tekrar hatırlatmak istedim.

Bu arada evimizde oturup yaptığımız istek dünyayı dolaştı ama biz hala istediğimiz sayfayı görüntüleyemedik söyleyeceklerim bu kadar.. Şaka, daha çok yolumuz var.

![](https://cdn-images-1.medium.com/max/800/1*UCFZazVT4_FHo4rFclelzA.png)

En son Recursive DNS bu IP adresini kendi önbelleğine aldı bir de bunu bize geri iletmesi gerekecek. ISP’den sonra mahalle, sokak, evdeki modem kablosu derken artık domainin bu IP adresine denk geldiği bilgisi tarayıcımıza ulaşacak. Tarayıcı, `beyza.com` sunucusuna bağlanmak için IP adresini öğrendikten sonra veri alışverişi için bağlantı kurmak zorunda. Bu da TCP adı verilen protokolle yapılıyor. TCP bağlantısının gerçekleşmesi için 3'lü el sıkışma (three-way handshake) adı verilen bir işlem gerçekleştiriliyor. Bu işlemde TCP’nin gönderdiği 3 flag var.

![](https://cdn-images-1.medium.com/max/800/1*gMlKFPeuhax08P8aGQmBNw.png)

Bilgisayar önce sunucuya SYN adlı paket gönderir ve bu paket **_“ben seninle senkronize olmak istiyorum”_** anlamına gelen ve bağlantı kurmak istediğini söyleyen bir mesajdır. Sunucu da bu mesajı aldıktan sonra SYN-ACK paketi gönderir. Bu da **_“benimle senkronize olmak istediğin mesajını aldım ben de seninle senkronize olmak istiyorum”_** anlamına gelen bir mesajdır. Bilgisayar da bu paketi aldıktan sonra tekrar sunucuya ACK paketi gönderir ve **_“ben de benimle senkronize olmak istediğini anladım”_** anlamına gelen bilgi mesajını gönderir ve böylece bağlantı kurulmuş olur. Bundan sonraki kısımda tarayıcı en başta https bağlantısı kurmayı seçtiği için verilerin şifreli olarak gönderilmesini sağlayacak. Yani TLS protokolü devreye girecek. Bu da 2 cihaz arasında güvenli bağlantı kurmak için anlaşmadır diyebiliriz. Peki TLS bağlantısı hangi aşamalardan geçerek kuruluyor? TLS’in de TCP gibi el sıkışma süreci var fakat bu 2 aşamadan oluşuyor. Bu aşamalarda amaç, tarayıcı ve sunucunun birbirlerine hangi şifreleme algoritmalarını kullanacaklarını söylemek ve tarayıcının gerçekten `beyza.com` sunucusuna bağlandığından emin olmaktır.

![](https://cdn-images-1.medium.com/max/800/1*CLbmMotKOVaP5Ex7-SvgJg.png)

Yukarıdaki çizimimde görüldüğü üzere tarayıcı sunucuya **_“merhaba”_** anlamına gelen bir Client Hello mesajı gönderir. Bu mesajın içeriğinde tahmin edeceğiniz üzere sadece merhaba yazmıyor tabii ki 😄 Mesaj içeriğinde;

*   Desteklediği şifreleme algoritmaları **_(mesela AES, RSA gibi)_**
*   TLS protokol versiyonu **_(mesela TLS 1.2 ya da TLS 1.3 gibi sürümler olabilir)_**
*   Bağlantıyı benzersiz bir hale getirmek için random bir sayı

Bu mesajı göndermek yani içinde bunları bulundurma amacı da güvenli bağlantı kurarken uyum sağlamaya çalışmasından kaynaklanıyor. **_“Ben bu algoritmaları ve bu sürümleri kullanıyorum haberin olsun sen de ona göre kullan ki uyumlu çalışabilelim”_** demek istiyor. Tarayıcı bu bilgileri gönderdikten sonra sunucu bu isteği alıyor ve desteklediği özellikleri tarayıcınınkilerle karşılaştırıyor. Ona karşılık olarak **_“sana da merhaba”_** anlamına gelen bir Server Hello mesajı gönderiyor. Şimdi de Server Hello mesajında neler var ona bakalım;

*   Sunucu, tarayıcının ona önerdiği şifreleme algoritmalarından birini seçer. Örnek olarak RSA ve AES yazmıştım burada da atıyorum RSA seçti bunu gönderir.
*   Tarayıcının gönderdiği random sayıya kendi random sayısını da birleştirerek daha güvenli bir anahtar oluşmasını sağlar ve onu gönderir.

Böylece Server Hello mesajı da tarayıcıya ulaşır. Ardından sunucu kim olduğunu kanıtlamak için bir SSL/TLS sertifikası gönderir. Bu sertifikaya, kim olduğunu ve gerçekten `beyza.com`’a ait olduğunu kanıtlayan belgedir diyebiliriz. Ayrıca bu sertifikada public key bulunur. Çünkü bu anahtar, daha sonra şifreleme anahtarının güvenli bir şekilde paylaşılmasını sağlayacak. Tarayıcı, sunucunun gönderdiği sertifikayı doğrulayıp kimliğinin geçerli olup olmadığını kontrol eder. Nasıl mı? Şöyle, sertifika CA (Sertifika Otoritesi) tarafından yani güvenilir bir sertifika otoritesi tarafından imzalanmış olmalıdır. Eğer tarayıcı bunu kontrol ettiğinde sertifika doğrulanmazsa tarayıcı, kullanıcıya bir uyarı gösterir. Bu uyarıyı hepimiz en az 1 kez görmüşüzdür **_“Bu site güvenli değil”_** şeklinde. Sertifika doğrulanırsa tarayıcı, sunucunun kimliğine güvenir.

![](https://cdn-images-1.medium.com/max/800/0*OUOuv9vUtWPHpwMx.png)

Bundan sonraki aşamada tarayıcı ve sunucu güvenli bağlantı için anahtar paylaşımı yapacak fakat bu anahtar aradaki iletişimin güvenli olması için korunmalı. Tarayıcı, bağlantıyı şifrelemek için Pre-Master Secret adı verilen özel bir anahtar oluşturur. Bu da tarayıcıyla sunucu arasında daha sonra türetilecek olan şifreleme temelini oluşturacak. Tarayıcının, bu anahtarı nasıl göndereceğine gelirsek, sunucunun sertifikasında bulunan public key ile şifreleyip sunucuya gönderir. Böylelikle, sadece sunucu kendi özel anahtarıyla bu mesajı çözebilir ve pre-master secret’ı çözebilir. Bu aşamadan sonra da artık aralarında güvenli bağlantı temeli için Master Secret adı verilen anahtarı üretirler. Bu, hem tarayıcı hem de sunucunun bildiği random sayılar ve pre-master secret kullanarak hesaplanıyor. Şimdi de aklımızda **_“Master Secret ne işe yarar?”_** diye bir soru belirmiş olabilir. Master secret, artık 2 taraf arasında gönderilecek verilerin şifrelenmesinde ve kullanılacak simetrik şifreleme anahtarlarının üretilmesinde görev alacak. Bu arada şifreleme algoritmaları simetrik ve asimetrik olarak 2 farklı başlıkta incelenebilir. Ben burada ikisi arasındaki farktan bahsedicem önce. Simetrik, iletişimin yoğun olduğu ve büyük veri paketlerinin iletilmesi gerektiğinde kullanılırken, asimetrik şifreleme de veri aktarımından önce güvenli iletişim kanalını oluştururken kimlik doğrulayarak güvenli bir iletişim hattı kurmak için kullanılır. Şimdi master secret’ın neden simetrik olduğuna gelecek olursak, veri aktarımı sırasında daha hızlıdır ve aynı anahtar, veri şifreleme ve çözme işlemleri için kullanılır. Bu yüzden veri transferi boyunca bu anahtar kullanılacaktır. Buradan sonraki kısımda da artık kendi taraflarında anahtarların ve ayarların başarılı bir şekilde tamamlandığını doğrulamak için birbirlerine **_“görevimiz tamamlandı dağılabiliriz”_** anlamına gelen Finished mesajı gönderirler. Bu mesaj geldiğinde artık anlarlar ki TLS handshake süreci başarılı bir şekilde bitti ve 2 tarafta da ayarlar uyumlu. Bu mesajdan sonra tüm bağlantı tamamen şifreli haldedir ve eğer bir veri iletecekse en son oluşturulan simetrik anahtarlarla şifrelenmiş olarak iletilecektir. Buradan sonraki kısımda web sayfasının içeriğini almak için bir HTTP GET isteği yapılır. Bu istek de **_“ana sayfayı bana gönder”_** anlamına gelir. İlk olarak tarayıcı sayfayı yüklemek için HTTP GET isteği oluşturur. Bu isteğin içinde sunucuya bazı bilgiler gönderilir mesela tarayıcının IP adresi, User-Agent bilgisi, istenilen sayfanın yolu gibi.

![](https://cdn-images-1.medium.com/max/800/1*e5ZpCjCeOqtZZ01csj2JNg.png)

Bu şekilde header’lar düşünebiliriz. Bu header’lar paketin nereye gitmesi gerektiğini ve kimden geldiğini belirten özelliklere sahiptir. Daha detaylı bilgi için [buradaki](/post/2) yazıma gidebilirsiniz. Paketler oluşturulduktan sonra tarayıcı bu paketleri bilgisayarımızın NIC yani ağ arayüz kartına gönderir. Paketler artık modemden geçip internete doğru gider ve yine ISP’ye kadar olan yol gerçekleşir. Artık ISP’de DNS çözümlemesinden sonra belirlenen `beyza.com IP: 12.1.1.12` adresi olduğu için direkt sunucuya ulaşmaya gider. Tarayıcıdan gelen paketler IP adresine ulaştığında, sunucu bu paketleri alıp birleştirir. Böylece orijinal GET isteği yeniden oluşturulur. Sunucu bu isteği okur ve ana sayfa içeriğini hazırlar. Bu aşamada da HTML, CSS, JS gibi içerikleri tarayıcıya geri göndermek üzere hazırlıyor. Hazırladıktan sonra yine TCP ile iletileceği için sayfa içeriğini paketlere bölüp gönderir. Tarayıcı da yeniden paketleri birleştirip şifreyi çözer ve sayfa içeriğine ulaşır. Son olarak HTML’i render edip ana sayfayı kullanıcıya gösterir.

Bir isteğin serüveninin sonuna geldik umarım herkes için faydalı olmuştur. Kolaylıklar 💫
